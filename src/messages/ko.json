{
  "title": "JSON 포맷터",
  "subtitle": "온라인 JSON 포맷, 검증 및 압축 도구",
  "description": "JSON 데이터를 포맷, 검증, 압축 및 이스케이프 처리할 수 있는 무료 온라인 JSON 포맷 도구로, 개발자가 JSON 데이터를 더 효율적으로 처리할 수 있도록 도와줍니다.",
  "formatBtn": "포맷",
  "compressBtn": "압축",
  "clearBtn": "지우기",
  "uploadBtn": "업로드",
  "copyBtn": "복사",
  "downloadBtn": "다운로드",
  "historyBtn": "기록",
  "backToFormatter": "포맷터로 돌아가기",
  "removeEscapeBtn": "이스케이프 제거",
  "fullscreenBtn": "전체 화면",
  "exitFullscreenBtn": "전체 화면 종료",
  "inputLabel": "JSON 입력",
  "outputLabel": "포맷 결과",
  "language": "언어",
  "lineNumbers": {
    "show": "줄 번호 표시",
    "hide": "줄 번호 숨기기"
  },
  "errors": {
    "empty": "JSON은 비워둘 수 없습니다",
    "invalid": "유효하지 않은 JSON",
    "invalidEscape": "유효한 JSON 문자열이 아니어서 이스케이프 문자를 제거할 수 없습니다",
    "notString": "입력이 JSON 문자열이 아니어서 이스케이프 문자를 제거할 수 없습니다",
    "suggestion": "고침 제안",
    "autoFixAvailable": "이 오류는 자동으로 수정할 수 있습니다",
    "clickToFix": "클릭하여 수정 적용",
    "applyFix": "수정 적용"
  },
  "success": {
    "formatted": "JSON 포맷팅 완료",
    "compressed": "JSON 압축 완료",
    "copied": "클립보드에 복사됨",
    "unescaped": "이스케이프 문자 제거 성공",
    "noEscapeNeeded": "문자열에 이스케이프 제거가 필요하지 않습니다",
    "fixApplied": "수정이 적용되었습니다"
  },
  "jsonErrors": {
    "unexpectedToken": "예상치 못한 토큰",
    "expected": "예상된",
    "inPosition": "JSON 위치",
    "clearMarkError": "마커 지우기 오류",
    "setMarkError": "마커 설정 오류",
    "fullscreenError": "전체화면 모드 오류",
    "saveHistoryError": "기록 저장 오류",
    "getHistoryError": "기록 가져오기 오류",
    "clearHistoryError": "기록 지우기 오류"
  },
  "suggestions": {
    "checkSyntax": "JSON 구문을 확인하세요. 특히 괄호, 중괄호, 따옴표의 짝이 맞는지 확인하세요",
    "missingClosingBracket": "닫는 괄호 또는 중괄호 누락",
    "missingClosingQuote": "닫는 따옴표 누락",
    "incompleteJson": "JSON이 불완전합니다. 누락된 부분이 있는지 확인하세요",
    "missingQuotesAroundKey": "속성 이름은 큰따옴표로 둘러싸야 합니다",
    "trailingComma": "JSON에서는 끝에 쉼표를 허용하지 않습니다",
    "missingComma": "값 사이에 쉼표가 없습니다",
    "singleQuotes": "JSON에서는 작은따옴표 대신 큰따옴표가 필요합니다",
    "booleanCase": "불리언 값은 소문자여야 합니다: {value}",
    "nullCase": "null 값은 소문자여야 합니다",
    "unescapedQuote": "문자열 내의 따옴표는 이스케이프 처리되어야 합니다"
  },
  "footer": {
    "copyright": "© 2025 JSON 포맷터 | 효율적인 도우미"
  },
  "languages": {
    "en": "영어",
    "zh": "중국어",
    "ja": "일본어",
    "ko": "한국어",
    "es": "스페인어",
    "de": "독일어",
    "fr": "프랑스어",
    "ru": "러시아어"
  },
  "history": {
    "title": "기록",
    "empty": "기록 없음",
    "noResults": "일치하는 기록 없음",
    "clear": "기록 지우기",
    "copy": "복사",
    "searchPlaceholder": "기록 검색...",
    "timeFilter": {
      "all": "전체",
      "today": "오늘",
      "week": "이번 주",
      "month": "이번 달"
    },
    "format": "포맷",
    "compress": "압축",
    "unescape": "이스케이프 제거",
    "operations": {
      "format": "포맷",
      "compress": "압축",
      "unescape": "이스케이프 제거"
    },
    "time": {
      "today": "오늘 {time}",
      "yesterday": "어제 {time}",
      "daysAgo": "{days}일 전 {time}"
    }
  },
  "feedbackBtn": "피드백",
  "feedback": {
    "title": "피드백",
    "content": "피드백 내용",
    "contentPlaceholder": "피드백을 입력해주세요...",
    "contact": "연락처 (선택사항)",
    "contactPlaceholder": "이메일 또는 기타 연락처 정보를 입력해주세요",
    "submit": "피드백 제출",
    "submitting": "제출 중...",
    "cancel": "취소",
    "success": "피드백을 보내주셔서 감사합니다!",
    "error": "제출 실패, 나중에 다시 시도해주세요",
    "validation": {
      "required": "이 항목을 입력해주세요",
      "invalidEmail": "유효한 이메일 주소를 입력해주세요"
    }
  },
  "showDemoBtn": "데모 보기",
  "hideDemoBtn": "데모 숨기기",
  "share": "공유",
  "shareMenu": {
    "title": "공유하기",
    "open": "공유 메뉴 열기",
    "close": "공유 메뉴 닫기"
  },
  "stats": {
    "totalVisits": "총 방문수",
    "onlineUsers": "온라인 사용자"
  },
  "breadcrumb": {
    "home": "홈",
    "history": "기록",
    "contact": "문의하기",
    "privacy": "개인정보처리방침",
    "terms": "이용약관",
    "beautify": "미화",
    "minify": "압축",
    "validate": "검증",
    "tutorials": "튜토리얼",
    "json-schema": "JSON 스키마 튜토리얼",
    "json-basics": "JSON 기초",
    "json-formats": "JSON 포맷팅 모범 사례",
    "json-vs-xml": "JSON 대 XML",
    "json-localstorage": "JSON과 LocalStorage",
    "json-path": "JSONPath",
    "json-api": "JSON API 설계",
    "json-to-code": "JSON에서 코드로",
    "blog": "블로그"
  },
  "basics": {
    "pageTitle": "JSON 기초 - 데이터 유형, 구문 및 구조",
    "introduction": {
      "description": "JSON(JavaScript Object Notation)은 사람이 읽고 쓰기 쉽고 기계가 분석하고 생성하기 쉬운 경량 데이터 교환 형식입니다. 이 튜토리얼은 구문 규칙, 데이터 유형 및 구조를 포함한 JSON의 기초를 포괄적으로 이해하는 데 도움이 될 것입니다."
    },
    "whatIsJson": {
      "title": "JSON이란 무엇인가?",
      "description": "JSON은 2000년대 초 Douglas Crockford가 제안한 텍스트 기반의 사람이 읽을 수 있는 데이터 교환 형식입니다. JavaScript Object Notation의 약자로, JavaScript 언어에서 유래했지만 현재는 거의 모든 프로그래밍 언어에서 지원하는 언어 독립적인 데이터 형식입니다.",
      "keyFeatures": {
        "title": "주요 특징",
        "item1": "경량 - XML과 같은 형식보다 간결하고, 전송 및 분석이 더 효율적",
        "item2": "자기 설명적 - 명확한 형식, 이해하기 쉬움",
        "item3": "언어 독립적 - 거의 모든 프로그래밍 언어에는 JSON을 처리하는 라이브러리가 있음",
        "item4": "텍스트 기반 - 유니코드 인코딩을 사용하여 다국어 콘텐츠 표현 가능",
        "item5": "구조화 - 중첩 데이터를 지원하고, 복잡한 데이터 관계를 표현할 수 있음"
      }
    },
    "jsonSyntax": {
      "title": "JSON 구문",
      "description": "JSON 구문은 몇 가지 기본 규칙만 있어 매우 간단합니다:",
      "rule1": "데이터는 키와 값의 쌍으로 표현되며, 형식은 \"키\": 값",
      "rule2": "데이터 항목은 쉼표로 구분됨",
      "rule3": "객체(순서가 없는 키-값 쌍 집합)는 중괄호 {{}}로 표현됨",
      "rule4": "배열(순서가 있는 값 목록)은 대괄호 [[]]로 표현됨",
      "rule5": "모든 키는 큰따옴표로 묶어야 함",
      "completeExample": "다음은 다양한 JSON 요소를 포함하는 완전한 예시입니다:",
      "validJson": "이것은 문자열, 숫자, 불리언, 배열, 중첩 객체 및 null을 포함하는 유효한 JSON 객체입니다."
    },
    "jsonDataTypes": {
      "title": "JSON 데이터 유형",
      "description": "JSON은 다음 여섯 가지 데이터 유형을 지원합니다:",
      "string": "문자열",
      "stringDescription": "텍스트 데이터, 반드시 큰따옴표로 둘러싸야 하며, 이스케이프 문자를 지원합니다.",
      "number": "숫자",
      "numberDescription": "정수 또는 부동 소수점 숫자, NaN이나 Infinity와 같은 비숫자 값은 지원하지 않습니다.",
      "boolean": "불리언",
      "booleanDescription": "true 또는 false (반드시 소문자여야 함).",
      "null": "Null",
      "nullDescription": "비어 있거나 존재하지 않는 값을 나타내며, null(반드시 소문자여야 함)을 사용합니다.",
      "object": "객체",
      "objectDescription": "키-값 쌍의 순서가 없는 집합, 키는 반드시 문자열이어야 하며, 값은 모든 JSON 데이터 유형이 될 수 있습니다.",
      "array": "배열",
      "arrayDescription": "값의 순서가 있는 집합, 모든 JSON 데이터 유형을 포함할 수 있으며, 서로 다른 유형을 혼합할 수도 있습니다.",
      "noteTitle": "중요 참고사항",
      "noteDescription": "JSON에는 다른 형식과 다른 몇 가지 중요한 제한사항이 있습니다:",
      "noteItem1": "주석을 지원하지 않음",
      "noteItem2": "모든 키 이름은 작은따옴표가 아닌 큰따옴표로 둘러싸야 함",
      "noteItem3": "undefined 값을 지원하지 않음",
      "noteItem4": "날짜 유형을 직접 지원하지 않음(문자열이나 숫자로 변환해야 함)",
      "noteItem5": "함수나 메서드를 지원하지 않음"
    },
    "jsonStructure": {
      "title": "JSON 구조",
      "description": "JSON의 유연성은 여러 계층의 중첩된 객체와 배열을 포함한 복잡한 중첩 데이터 구조를 표현할 수 있게 합니다. 이로 인해 거의 모든 유형의 데이터를 표현하는 데 매우 적합합니다.",
      "exampleDescription": "다음은 다중 레벨 데이터를 구성하는 방법을 보여주는 더 복잡한 JSON 구조의 예입니다:",
      "exampleExplanation": "이 예시는 JSON이 중첩된 객체와 배열을 통해 복잡한 데이터 구조를 어떻게 표현할 수 있는지 보여줍니다. 제품 카탈로그에는 카테고리가 포함되어 있고, 카테고리에는 제품이 포함되어 있으며, 제품에는 사양 및 색상 목록과 같은 세부 정보가 포함되어 있습니다."
    },
    "commonMistakes": {
      "title": "일반적인 실수",
      "description": "JSON을 다룰 때 피해야 할 몇 가지 일반적인 실수가 있습니다:",
      "commonErrors": "일반적인 JSON 구문 오류",
      "error1": "큰따옴표 대신 작은따옴표 사용",
      "error1Description": "JSON은 모든 문자열(키 이름 포함)에 큰따옴표를 사용해야 합니다.",
      "error2": "마지막 항목 뒤에 추가 쉼표",
      "error2Description": "JSON은 마지막 요소 뒤에 쉼표를 허용하지 않습니다. 이는 일부 프로그래밍 언어와 다릅니다.",
      "error3": "속성 이름 주위에 따옴표를 넣지 않음",
      "error3Description": "모든 객체 속성 이름은 큰따옴표로 둘러싸야 합니다. JavaScript 객체에서는 생략할 수 있는 것과 달리 JSON에서는 필수입니다.",
      "error4": "JSON에 주석 추가",
      "error4Description": "JSON은 주석을 지원하지 않습니다. 어떤 형태의 주석도 구문 분석 오류를 일으킵니다.",
      "bestPractices": "모범 사례",
      "bestPractice1": "검증 도구 사용",
      "bestPractice1Description": "항상 JSON 검증 도구를 사용하여 JSON이 유효한지 확인하세요.",
      "bestPractice2": "포맷팅 도구 사용",
      "bestPractice2Description": "JSON 포맷팅은 가독성을 향상시키고 오류를 더 쉽게 발견할 수 있게 합니다.",
      "bestPractice3": "데이터 유형에 주의",
      "bestPractice3Description": "올바른 데이터 유형을 사용하고 있는지 확인하세요. 특히 문자열과 숫자를 구분하는 것이 중요합니다.",
      "bestPractice4": "이스케이프 문자 주의",
      "bestPractice4Description": "특수 문자, 특히 문자열 내의 따옴표와 백슬래시를 올바르게 이스케이프 처리하세요.",
      "bestPractice5": "파싱 라이브러리 특성 이해",
      "bestPractice5Description": "다른 언어의 JSON 파싱 라이브러리는 미묘한 차이가 있을 수 있습니다. 사용 중인 라이브러리의 특정 동작을 이해하세요."
    },
    "toolsLibraries": {
      "title": "JSON 도구 및 라이브러리",
      "description": "JSON 작업에 도움이 되는 많은 도구와 라이브러리가 있습니다:",
      "onlineTools": "온라인 도구",
      "tool1": "JSON 포맷터",
      "tool1Description": "JSON 데이터를 포맷팅하여 가독성을 향상시킵니다.",
      "tool2": "JSON 검증기",
      "tool2Description": "JSON 구문이 올바른지 확인합니다.",
      "tool3": "JSON 비교 도구",
      "tool3Description": "두 JSON 객체 간의 차이점을 비교합니다.",
      "tool4": "JSON 변환기",
      "tool4Description": "JSON과 다른 형식(XML, CSV 등) 간 변환을 수행합니다.",
      "programmingLibraries": "프로그래밍 라이브러리",
      "library1": "JavaScript",
      "library1Item1": "내장 JSON.parse() 및 JSON.stringify()",
      "library1Item2": "Lodash - 더 많은 JSON 조작 기능 제공",
      "library1Item3": "json5 - 주석을 지원하는 확장된 JSON 버전",
      "library2": "Python",
      "library2Item1": "내장 json 모듈",
      "library2Item2": "simplejson - 더 고급 JSON 라이브러리",
      "library2Item3": "ujson - 고성능 JSON 인코더 및 디코더",
      "library3": "Java",
      "library3Item1": "Jackson - 기능이 풍부한 JSON 처리 라이브러리",
      "library3Item2": "Gson - Google에서 개발한 JSON 라이브러리",
      "library3Item3": "JSON-java - 경량 JSON 라이브러리"
    },
    "conclusion": {
      "title": "결론",
      "description": "이 튜토리얼을 통해 JSON의 기본 사항을 배웠습니다:",
      "item1": "JSON의 기본 개념 및 특징",
      "item2": "JSON 구문 규칙 및 데이터 유형",
      "item3": "복잡한 JSON 구조를 생성하고 파싱하는 방법",
      "item4": "일반적인 오류 및 모범 사례",
      "item5": "유용한 JSON 도구 및 라이브러리",
      "finalDescription": "JSON 마스터링은 현대 소프트웨어 개발에서 필수적인 기술입니다. API와 데이터 교환의 보편화로 이러한 지식은 개발 경력 전반에 걸쳐 자주 사용될 것입니다. 계속해서 다른 튜토리얼을 탐색하여 JSON에 관한 고급 주제를 더 배워보세요."
    },
    "returnToTutorials": "튜토리얼 목록으로 돌아가기",
    "nextTutorial": "다음 튜토리얼: JSON 스키마"
  },
  "schema": {
    "pageTitle": "JSON 스키마 튜토리얼",
    "pageDescription": "JSON 스키마를 배우고 JSON 데이터를 검증하는 방법과 응용 프로그램에서 JSON 스키마를 구현하는 방법 이해하기",
    "introduction": {
      "title": "JSON 스키마 소개",
      "description": "JSON 스키마는 JSON 문서에 주석을 달고 검증할 수 있는 어휘입니다. JSON 데이터의 구조, 내용 및 검증 규칙을 정의하는 데 도움이 됩니다."
    },
    "basics": {
      "title": "JSON 스키마 기초",
      "description": "JSON 스키마 자체가 JSON 문서입니다. 스키마는 다음을 정의합니다:"
    },
    "validation": {
      "title": "JSON 스키마를 사용한 검증",
      "description": "검증은 JSON 스키마의 주요 목적 중 하나입니다. 이 섹션에서는 JSON 스키마가 지정된 제약 조건에 대해 데이터를 검증하는 방법, 검증 규칙을 정의하는 방법, 검증 오류를 효과적으로 처리하는 방법을 설명합니다."
    },
    "advanced": {
      "title": "고급 JSON 스키마 기능",
      "description": "참조($ref), 조건부 검증, 형식 검증 및 사용자 정의 어휘를 포함한 JSON 스키마의 고급 기능을 탐색합니다. 복잡한 JSON 데이터 구조에 대한 복잡한 스키마를 만드는 방법을 배웁니다."
    },
    "tools": {
      "title": "JSON 스키마 도구 및 라이브러리",
      "description": "Node.js용 Ajv, 웹 기반 스키마 생성을 위한 JsonSchema.Net과 같은 JSON 스키마를 지원하는 인기 있는 도구와 라이브러리를 발견하고 다양한 프로그래밍 언어 및 프레임워크와의 통합 옵션을 알아보세요."
    }
  },
  "formats": {
    "pageTitle": "JSON 포맷팅 모범 사례",
    "introduction": {
      "title": "JSON 포맷팅이 중요한 이유",
      "description": "JSON 구문은 단순하지만, 좋은 포맷팅 습관은 가독성, 유지 관리성을 향상시키고 오류를 줄이는 데 필수적입니다. API 응답, 구성 파일 또는 데이터 저장소를 만들든, 일관된 포맷팅 규칙을 따르면 여러분과 팀원이 JSON 데이터를 더 쉽게 처리할 수 있습니다."
    },
    "detailedDescription": "이 튜토리얼에서는 들여쓰기, 명명 규칙, 데이터 구성 및 도구 사용을 포함한 JSON 포맷팅 모범 사례를 소개합니다.",
    "indentation": {
      "title": "들여쓰기 및 공백",
      "description": "적절한 들여쓰기는 JSON 가독성을 향상시키는 핵심입니다:",
      "guideline1": "일관된 들여쓰기 사용 (2칸 또는 4칸 공백이 일반적인 선택)",
      "guideline2": "중첩된 각 레벨마다 들여쓰기를 한 수준 증가",
      "guideline3": "배열과 객체의 시작 및 종료 괄호는 정렬되어야 함",
      "recommended": "권장 사례:",
      "notRecommended": "권장하지 않는 사례:"
    },
    "namingConventions": {
      "title": "명명 규칙",
      "description": "일관된 명명 규칙은 JSON 데이터의 가독성과 유지 관리성을 향상시킵니다:",
      "camelCase": "카멜케이스 사용: firstName, lastLogin과 같이 JSON에서 가장 일반적인 명명 규칙",
      "avoidUnderscores": "밑줄 사용 피하기: 일부 API에서는 snake_case를 사용하지만, JavaScript 환경에서는 카멜케이스가 더 일반적",
      "descriptiveNames": "설명적인 이름 사용: 키는 포함하는 데이터를 명확하게 표현해야 함",
      "avoidAbbreviations": "약어 피하기: ID와 같이 널리 통용되는 약어가 아니라면 완전한 단어 사용",
      "consistency": "일관성 유지: 프로젝트 전체에서 동일한 명명 규칙 사용",
      "recommended": "권장 사례:",
      "notRecommended": "권장하지 않는 사례:"
    },
    "dataOrganization": {
      "title": "데이터 구성",
      "description": "데이터 구조를 적절히 구성하면 JSON 가독성과 사용 효율성을 향상시킬 수 있습니다:",
      "groupRelated": "관련 속성 그룹화: 관련 속성을 함께 배치하고 중첩 객체를 사용하여 복잡한 데이터 구성",
      "logicalOrder": "논리적 순서로 속성 배열: ID나 이름을 먼저 배치하고 그 다음에 상세 정보 배치",
      "consistentTypes": "일관된 데이터 유형 유지: 예를 들어, 날짜에는 항상 같은 형식 사용",
      "arrayItems": "배열의 항목은 동일한 구조를 가져야 함: 배열이 객체를 포함한다면, 이러한 객체들은 동일한 속성 집합을 가져야 함"
    },
    "dateNumberFormats": {
      "title": "날짜 및 숫자 형식",
      "description": "날짜와 숫자 서식은 데이터 일관성에 중요합니다:",
      "dateFormats": "날짜 형식",
      "useISO": "표준 ISO 8601 형식 사용: YYYY-MM-DDTHH:mm:ss.sssZ",
      "example": "예: \"2023-05-15T14:30:00Z\" 또는 \"2023-05-15\"(날짜만)",
      "avoidLocalized": "지역화된 날짜 형식 피하기, 예를 들어 \"05/15/2023\"는 지역에 따라 다르게 해석될 수 있음",
      "numberFormats": "숫자 형식",
      "avoidSeparators": "JSON에서 천 단위 구분자(예: 1,000) 사용 피하기",
      "currencyPrecision": "통화 값은 정밀도를 지정해야 함(일반적으로 소수점 두 자리)",
      "largeNumbers": "JavaScript의 안전한 정수 범위를 넘어서는 큰 숫자는 문자열로 표현하는 것 고려"
    },
    "validation": {
      "title": "검증 및 확인",
      "description": "JSON이 올바르게 포맷되고 유효한지 확인하세요:",
      "useTools": "검증 도구 사용: JSONLint와 같은 도구로 게시 전 JSON 유효성 검증",
      "useSchema": "JSON 스키마 사용: 데이터 구조 및 검증 규칙 정의",
      "checkErrors": "일반적인 오류 확인: 누락된 쉼표, 추가 쉼표, 닫히지 않은 따옴표 등",
      "autoFormat": "자동 포맷팅: 일관성을 유지하기 위해 편집기 포맷팅 기능 사용",
      "ourTool": "우리의 JSON 검증 도구를 사용하여 JSON이 유효한지 확인할 수 있습니다."
    },
    "compression": {
      "title": "압축 및 미화",
      "description": "다른 시나리오에 맞는 적절한 포맷팅 선택:",
      "devDebug": "개발 및 디버깅: 가독성을 위해 미화된 형식(들여쓰기 및 줄바꿈 포함) 사용",
      "production": "프로덕션 환경: 데이터 크기를 줄이기 위해 압축된 형식(모든 공백 제거) 사용",
      "apiResponses": "API 응답: 클라이언트가 미화된 형식과 압축된 형식 중 선택할 수 있는 형식 옵션 제공 고려",
      "largeFiles": "대용량 파일: 전송 및 저장에는 항상 압축된 형식 사용",
      "beautified": "미화된 형식(개발용):",
      "compressed": "압축된 형식(프로덕션용):"
    },
    "whitespacePlacement": {
      "title": "공백 배치",
      "description": "전략적 공백 배치는 가독성을 향상시킵니다:",
      "afterColons": "키-값 쌍의 콜론 뒤에 공백 추가",
      "afterCommas": "배열과 객체의 쉼표 뒤에 공백 추가",
      "noExtraSpaces": "콜론이나 쉼표 앞에 공백 추가하지 않기",
      "lineBreaks": "미화된 형식에서는 속성과 배열 항목을 구분하기 위해 줄바꿈 사용",
      "recommended": "권장 사례:",
      "notRecommended": "권장하지 않는 사례:"
    },
    "securityConsiderations": {
      "title": "보안 고려사항",
      "description": "민감한 정보가 포함될 수 있는 JSON을 포맷팅할 때는 주의하세요:",
      "sensitiveData": "클라이언트 측 JSON에 민감한 데이터(비밀번호, API 키 등)를 절대 포함하지 마세요",
      "validateInput": "외부 소스에서 가져온 JSON 입력은 항상 검증하고 살균하세요",
      "avoidComments": "JSON은 주석을 지원하지 않는다는 점을 기억하세요 - 민감한 데이터를 '숨기기' 위해 주석을 사용하지 마세요",
      "handleErrors": "JSON 파싱 실패에 대한 적절한 오류 처리 구현"
    },
    "tools": {
      "title": "포맷팅 도구",
      "description": "일관된 JSON 포맷팅을 유지하는 데 도움을 주는 여러 도구:",
      "onlineTools": "온라인 도구:",
      "ourFormatter": "우리의 JSON 포맷터: 클릭 한 번으로 JSON을 포맷 및 미화",
      "jsonlint": "JSONLint: JSON 검증 및 구문 오류 식별",
      "editorPlugins": "에디터 플러그인:",
      "vscode": "VS Code: Prettier 통합이 포함된 내장 JSON 포맷팅",
      "webstorm": "WebStorm/IntelliJ IDEA: 사용자 정의 가능한 포맷팅 옵션이 있는 고급 JSON 지원",
      "sublime": "Sublime Text: JSON 포맷팅을 위한 다양한 패키지 사용 가능",
      "cliTools": "명령줄 도구:",
      "jq": "jq: 포맷팅 기능이 있는 명령줄 JSON 프로세서",
      "prettier": "Prettier: JSON 및 다른 많은 언어를 지원하는 코드 포맷터"
    },
    "bestPractices": {
      "title": "모범 사례 요약",
      "description": "JSON 포맷팅 모범 사례의 핵심 포인트를 요약하면:",
      "point1": "일관된 들여쓰기 사용(2칸 또는 4칸 공백)",
      "point2": "일관된 명명 규칙 준수(가급적 카멜케이스)",
      "point3": "관련 데이터를 논리적이고 일관되게 구성",
      "point4": "날짜(ISO 8601)와 숫자에 표준 형식 사용",
      "point5": "사용 또는 게시 전 JSON 검증",
      "point6": "개발에는 미화된 형식, 프로덕션에는 압축된 형식 사용",
      "point7": "가독성 향상을 위해 전략적으로 공백 배치",
      "point8": "JSON 포맷팅 시 보안 영향 고려",
      "point9": "포맷팅 규칙을 자동화하고 적용하기 위해 사용 가능한 도구 활용"
    },
    "conclusion": {
      "title": "결론",
      "description": "좋은 JSON 포맷팅 관행은 데이터를 더 읽기 쉽게 만들 뿐만 아니라 오류를 줄이고 유지 관리성을 향상시킵니다. 이 튜토리얼의 지침을 따르고 적절한 도구를 사용하면 JSON 데이터가 잘 구조화되고 일관성 있으며 다루기 쉽게 할 수 있습니다.",
      "nextSteps": "다른 JSON 튜토리얼을 계속 탐색하여 다양한 상황에서 JSON 데이터 작업에 대해 자세히 알아보세요."
    }
  },
  "localstorage": {
    "pageTitle": "JSON과 LocalStorage",
    "introduction": {
      "title": "소개",
      "description": "LocalStorage는 웹 브라우저가 제공하는 간단한 클라이언트 측 저장 메커니즘으로, 사용자 브라우저에 키-값 쌍을 영구적으로 저장할 수 있습니다. JSON 형식과 결합하면 LocalStorage는 프론트엔드 개발에서 구조화된 데이터를 저장하기 위한 강력한 도구가 됩니다."
    },
    "conclusion": {
      "title": "결론",
      "description": "JSON과 LocalStorage의 조합은 브라우저에 구조화된 데이터를 저장하는 강력한 방법을 제공합니다. 이 튜토리얼에서 설명한 패턴과 모범 사례를 따르면 웹 애플리케이션에 효과적으로 클라이언트 측 데이터 지속성을 구현할 수 있습니다.",
      "keyConcepts": "학습한 주요 개념:",
      "concept1": "저장을 위해 JavaScript 객체와 배열을 JSON으로 변환하는 방법",
      "concept2": "LocalStorage 상호 작용을 단순화하는 유틸리티 생성",
      "concept3": "LocalStorage에서 복잡한 데이터 구조 관리",
      "concept4": "쇼핑 카트와 사용자 환경설정과 같은 일반적인 패턴 구현",
      "concept5": "LocalStorage의 제한 사항과 대안 이해",
      "furtherReading": "더 고급 사용을 위해 IndexedDB API 또는 로컬 스토리지와 통합되는 상태 관리 라이브러리 탐색을 고려해 보세요."
    },
    "tutorials": {
      "title": "관련 튜토리얼",
      "otherTutorials": "다른 관련 튜토리얼도 확인해보세요:",
      "jsonBasics": "JSON 기본",
      "jsonSchema": "JSON 스키마 검증",
      "jsonAPIs": "JSON과 API 사용하기"
    }
  },
  "xmlcompare": {
    "pageTitle": "JSON 대 XML",
    "introduction": {
      "title": "소개",
      "description": "JSON(JavaScript Object Notation)과 XML(eXtensible Markup Language)은 두 가지 일반적인 데이터 교환 형식입니다. 둘 다 서로 다른 시스템 간에 데이터를 전송하는 데 사용되지만, 구문, 구조 및 사용 사례에 상당한 차이가 있습니다."
    },
    "detailedDescription": "이 튜토리얼은 이 두 형식을 자세히 비교하여 각각의 장단점을 이해하고 프로젝트에 가장 적합한 데이터 형식을 선택하는 데 도움을 줍니다.",
    "syntaxComparison": {
      "title": "구문 비교",
      "description": "다음은 동일한 데이터를 나타내는 JSON과 XML의 비교입니다:",
      "jsonFormat": "JSON 형식:",
      "xmlFormat": "XML 형식:"
    },
    "syntaxDifferences": {
      "description": "위의 예시에서 두 형식 간의 주요 구문 차이점을 확인할 수 있습니다:",
      "item1": "JSON은 객체에 중괄호 {{}}, 배열에 대괄호 [[]]를 사용합니다",
      "item2": "XML은 사용자 정의 태그와 중첩 구조를 사용합니다",
      "item3": "JSON은 더 간결하며 문자 수가 적습니다",
      "item4": "XML은 열기 및 닫기 태그를 사용하여 구조를 더 명확하게 만들지만 더 장황합니다"
    },
    "keyDifferences": {
      "title": "주요 차이점",
      "columns": {
        "feature": "기능",
        "json": "JSON",
        "xml": "XML"
      },
      "syntax": {
        "name": "구문",
        "json": "간결함, 키-값 쌍 기반",
        "xml": "태그 기반, 열기 및 닫기 태그 사용"
      },
      "fileSize": {
        "name": "파일 크기",
        "json": "더 작음",
        "xml": "더 큼"
      },
      "parsingSpeed": {
        "name": "구문 분석 속도",
        "json": "더 빠름",
        "xml": "더 느림"
      },
      "dataTypes": {
        "name": "데이터 유형",
        "json": "문자열, 숫자, 불리언, 배열, 객체 및 null 지원",
        "xml": "모든 데이터는 문자열이며, 추가 스키마 정의 필요"
      },
      "commentSupport": {
        "name": "주석 지원",
        "json": "지원되지 않음",
        "xml": "지원됨"
      },
      "namespace": {
        "name": "네임스페이스",
        "json": "지원되지 않음",
        "xml": "지원됨"
      },
      "readability": {
        "name": "가독성",
        "json": "단순한 데이터 구조에 더 좋음",
        "xml": "복잡한 데이터 구조에 더 좋음"
      },
      "languageSupport": {
        "name": "언어 지원",
        "json": "JavaScript에서 기본 지원, 다른 언어에서는 라이브러리 필요",
        "xml": "모든 주요 프로그래밍 언어에서 라이브러리 사용 가능"
      },
      "validation": {
        "name": "유효성 검사",
        "json": "JSON 스키마를 통해",
        "xml": "DTD, XSD를 통해"
      }
    },
    "jsonAdvantages": {
      "title": "JSON의 장점",
      "lightweight": "경량: JSON 파일은 일반적으로 동등한 XML 파일보다 작아 대역폭과 저장 공간 절약",
      "easyParsing": "간단한 구문 분석: 대부분의 프로그래밍 언어에는 JSON 구문 분석을 위한 기본 또는 써드파티 라이브러리가 있음",
      "readableWritable": "읽고 쓰기 쉬움: 간단한 구문으로 사람과 프로그램이 쉽게 이해할 수 있음",
      "javascriptIntegration": "JavaScript와 자연스러운 통합: 특히 웹 애플리케이션에서 유용",
      "fasterParsing": "더 빠른 구문 분석 속도: 특히 JavaScript 환경에서",
      "arraySupport": "배열 지원: 배열 구조에 대한 네이티브 지원",
      "popularInApis": "API에서 인기: 대부분의 현대 웹 API는 데이터 교환 형식으로 JSON 사용"
    },
    "xmlAdvantages": {
      "title": "XML의 장점",
      "validation": "강력한 유효성 검사: DTD 또는 XSD를 통한 엄격한 데이터 유효성 검사 제공",
      "namespaces": "네임스페이스 지원: 동일한 문서에서 다른 XML 어휘 사용 가능",
      "queryLanguage": "풍부한 쿼리 언어: XPath 및 XQuery가 강력한 쿼리 기능 제공",
      "comments": "주석 지원: XML 문서에 주석을 추가하여 가독성 향상 가능",
      "complexData": "복잡한 데이터 표현: 복잡한 계층 및 혼합 콘텐츠 표현에 더 적합",
      "ecosystem": "성숙한 생태계: 다수의 성숙한 도구 및 기술 보유",
      "selfDescribing": "자기 설명적: XML 문서는 일반적으로 메타데이터를 포함하여 더 자기 설명적임"
    },
    "whenToUseJson": {
      "title": "JSON을 사용해야 할 때",
      "description": "다음 상황에서는 JSON이 더 나은 선택입니다:",
      "webApps": "웹 애플리케이션 및 API 개발",
      "fastParsing": "빠른 구문 분석이 필요한 시나리오",
      "simpleStructures": "비교적 단순한 데이터 구조",
      "javascript": "JavaScript 환경(브라우저, Node.js)",
      "mobileApps": "모바일 애플리케이션 통신",
      "configFiles": "구성 파일(예: package.json)",
      "bandwidth": "대역폭 절약이 중요한 대량 데이터"
    },
    "whenToUseXml": {
      "title": "XML을 사용해야 할 때",
      "description": "다음 상황에서는 XML이 더 나은 선택입니다:",
      "strictValidation": "엄격한 데이터 유효성 검사가 필요한 경우",
      "complexStructures": "복잡한 문서 구조",
      "namespaceNeeded": "네임스페이스 사용이 필요한 경우",
      "commentsNeeded": "주석 지원이 필요한 경우",
      "documentOriented": "문서 지향 애플리케이션(Word, Excel 파일 형식 등)",
      "soapServices": "SOAP 웹 서비스",
      "xsltNeeded": "데이터 변환을 위해 XSLT 사용이 필요한 경우"
    },
    "conversion": {
      "title": "JSON과 XML 간 변환",
      "description": "때로는 두 형식 간에 변환해야 할 수도 있습니다. 많은 온라인 도구와 프로그래밍 라이브러리가 이 작업을 도울 수 있습니다:",
      "ourTool": "저희 JSON에서 XML로 변환 도구",
      "libraries": "xml2js와 같은 Node.js의 프로그래밍 라이브러리",
      "xslt": "XML을 JSON으로 변환하는 데 XSLT 사용 가능",
      "note": "변환 시 두 형식 간의 구조적 차이로 인해 변환된 데이터 구조가 원래 구조와 다를 수 있음을 참고하세요."
    },
    "conclusion": {
      "title": "결론",
      "description": "JSON과 XML은 각각 고유한 장단점이 있습니다. 형식 선택은 특정 요구 사항에 기반해야 합니다:",
      "chooseJson": "단순성, 구문 분석 속도 및 JavaScript 호환성이 중요하다면 JSON을 선택하세요",
      "chooseXml": "엄격한 데이터 검증, 복잡한 문서 구조 또는 네임스페이스 지원이 필요하다면 XML을 선택하세요",
      "modernDev": "현대 웹 개발에서 JSON은 특히 RESTful API에서 주류 데이터 교환 형식이 되었습니다. XML은 기업 애플리케이션, 문서 시스템 및 엄격한 데이터 검증이 필요한 시나리오에서 여전히 중요한 위치를 차지하고 있습니다.",
      "finalThought": "두 형식의 장단점을 이해하면 프로젝트에서 더 정보에 입각한 기술적 선택을 내리는 데 도움이 될 수 있습니다."
    }
  },
  "tutorials": "튜토리얼",
  "tutorialsPage": {
    "description": "기초부터 고급 기술까지 튜토리얼과 가이드로 JSON을 마스터하세요. 초보자든 전문 개발자든, 여기에서 적합한 콘텐츠를 찾을 수 있습니다.",
    "whyLearnJson": "왜 JSON을 배워야 할까요?",
    "webStandard": "웹 표준",
    "webStandardDesc": "JSON은 거의 모든 프로그래밍 언어에서 지원하는 현대 웹 API 및 데이터 교환을 위한 표준 형식입니다.",
    "lightweight": "경량 및 효율성",
    "lightweightDesc": "XML과 같은 형식에 비해 JSON은 더 가볍고 분석이 빠르며, 프론트엔드와 백엔드 간 데이터 전송에 이상적입니다.",
    "richTools": "풍부한 도구",
    "richToolsDesc": "풍부한 도구 생태계는 검증부터 변환까지 JSON 처리를 간단하게 만듭니다.",
    "levels": {
      "beginner": "초급",
      "intermediate": "중급",
      "advanced": "고급"
    },
    "comingSoon": "곧 제공 예정",
    "tooltipComingSoon": "이 튜토리얼은 현재 작성 중입니다. 기대해 주세요!",
    "notFound": "찾고 계신 튜토리얼이 없나요?",
    "addingMore": "우리는 계속해서 새로운 튜토리얼 콘텐츠를 추가하고 있습니다. 특정 주제에 관한 요청이 있으시면 알려주세요!",
    "requestTopic": "주제 요청하기",
    "commonQuestions": "일반적인 JSON 질문",
    "questions": {
      "jsObjectDiff": {
        "question": "JSON과 JavaScript 객체의 차이점은 무엇인가요?",
        "answer": "JSON은 JavaScript 객체 구문을 기반으로 하지만 몇 가지 주요 차이점이 있습니다: JSON은 일반 텍스트 형식이지만 JavaScript 객체는 실제 객체입니다; JSON 키는 큰따옴표로 둘러싸야 하지만 JavaScript 객체는 그럴 필요가 없습니다; JSON은 함수나 메서드를 지원하지 않지만 JavaScript 객체는 메서드를 포함할 수 있습니다; JSON은 주석을 허용하지 않지만 JavaScript 객체는 허용합니다."
      },
      "validation": {
        "question": "JSON이 유효한지 어떻게 검증하나요?",
        "answer": "우리의 JSON 검증 도구를 사용하여 JSON의 유효성을 확인할 수 있습니다. 일반적인 오류로는 쉼표 누락이나 추가, 일치하지 않는 따옴표, 큰따옴표 대신 작은따옴표 사용, 인용부호 없는 속성 이름 등이 있습니다. 유효한 JSON은 엄격한 구문 규칙을 따라야 하며, 우리 도구는 오류를 식별하고 수정하는 데 도움이 됩니다."
      },
      "dataTypes": {
        "question": "JSON은 어떤 데이터 유형을 지원하나요?",
        "answer": "JSON은 여섯 가지 데이터 유형을 지원합니다: 문자열(큰따옴표로 둘러싸인), 숫자(정수 또는 부동 소수점), 불리언(true 또는 false), 배열(순서가 있는 값 모음), 객체(키-값 쌍 모음) 및 null. JSON은 날짜, 함수, undefined 또는 정규 표현식을 직접 지원하지 않습니다."
      }
    },
    "relatedTools": {
      "title": "관련 도구",
      "formatter": "JSON 포맷터",
      "compressor": "JSON 압축기",
      "validator": "JSON 검증기",
      "jsonToXml": "JSON을 XML로"
    }
  },
  "categories": {
    "basic": {
      "name": "기본 지식",
      "description": "JSON의 기본 개념 및 사용법"
    },
    "advanced": {
      "name": "고급 기술",
      "description": "JSON의 고급 응용 및 기술에 대한 심층 분석"
    },
    "conversion": {
      "name": "변환 기술",
      "description": "JSON과 다른 형식 간의 변환 방법 및 도구"
    }
  },
  "jsonPath": {
    "description": "JSONPath를 사용하여 JSON 데이터를 쿼리하고 조작하기"
  },
  "jsonApi": {
    "description": "JSON 기반 API 설계 및 구축 방법 배우기"
  },
  "jsonToCode": {
    "description": "JSON 데이터를 다양한 프로그래밍 언어 코드로 변환",
    "pageTitle": "JSON에서 코드로 변환",
    "introduction": {
      "title": "JSON에서 코드로 변환 소개",
      "description": "JSON에서 코드로의 변환은 JSON 데이터 구조를 프로그래밍 언어 클래스나 타입으로 변환하는 소프트웨어 개발의 일반적인 프로세스입니다. 이 접근 방식은 타입 안전성과 개발자 경험을 향상시킵니다."
    },
    "benefits": {
      "title": "JSON에서 코드로 변환의 이점",
      "typeSafety": "타입 안전성: 타입이 지정된 클래스는 런타임 오류를 방지하는 데 도움이 됩니다",
      "intellisense": "IDE에서 향상된 자동 완성/IntelliSense",
      "maintainability": "명확하게 정의된 데이터 구조를 통한 유지 관리성 향상",
      "validation": "간소화된 유효성 검사 및 오류 처리",
      "refactoring": "코드 리팩토링 도구 지원"
    },
    "approaches": {
      "title": "변환 접근 방식",
      "manualCreation": "수동 생성: 알려진 JSON 구조를 기반으로 클래스 정의",
      "manualDesc": "단순하거나 자주 변경되지 않는 JSON 구조에 적합",
      "codeGeneration": "코드 생성: JSON 예제 또는 스키마에서 자동으로 클래스 생성",
      "codeGenDesc": "복잡하거나 자주 변경되는 JSON 구조에 권장",
      "dynamicDeserialization": "동적 역직렬화: 런타임 리플렉션 사용",
      "dynamicDesc": "구조가 미리 알려지지 않았을 때 유용"
    },
    "languages": {
      "title": "지원되는 언어",
      "description": "JSON에서 코드로의 변환은 다양한 프로그래밍 언어에 적용할 수 있습니다:",
      "typescript": "TypeScript - 강력한 타입 시스템 및 인터페이스",
      "csharp": "C# - 클래스 및 속성을 사용한 데이터 모델링",
      "java": "Java - POJO 클래스 및 Jackson/GSON 주석",
      "python": "Python - 데이터 클래스 또는 Pydantic 모델",
      "golang": "Go - 구조체 및 태그",
      "kotlin": "Kotlin - 데이터 클래스"
    },
    "implementation": {
      "title": "구현 방법",
      "description": "JSON을 코드로 변환하기 위한 몇 가지 일반적인 접근 방식이 있습니다:",
      "manualApproach": "수동 접근 방식",
      "manualDescription": "단순한 JSON 구조의 경우 해당 클래스를 직접 작성할 수 있습니다:",
      "toolApproach": "도구 기반 접근 방식",
      "toolDescription": "더 복잡한 구조의 경우 자동화 도구를 사용하는 것이 좋습니다:",
      "onlineTools": "온라인 도구",
      "onlineDescription": "JSON 샘플을 다양한 언어 코드로 변환하는 온라인 도구:"
    },
    "bestPractices": {
      "title": "모범 사례",
      "naming": "명명 규칙 고려",
      "namingDescription": "JSON과 프로그래밍 언어의 명명 규칙은 다를 수 있습니다. JSON의 카멜케이스 또는 스네이크케이스를 언어의 규칙으로 변환하세요.",
      "validation": "유효성 검사 추가",
      "validationDescription": "런타임 오류를 방지하기 위해 생성된 클래스에 데이터 유효성 검사 로직을 추가하세요.",
      "partialData": "부분 데이터 처리",
      "partialDescription": "JSON 데이터가 불완전한 경우를 처리하기 위한 전략을 구현하세요.",
      "versioning": "버전 관리",
      "versioningDescription": "JSON 구조가 시간이 지남에 따라 변경될 때의 업그레이드 경로를 계획하세요."
    }
  },
  "tutorials": "튜토리얼"
} 